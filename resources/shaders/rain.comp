#version 430

layout(local_size_x = 256) in;

layout(std430, binding = 0) buffer Raindrops {
    vec4 positions[];
};

layout(std430, binding = 1) buffer Velocities {
    vec4 velocities[];
};

layout(std430, binding = 2) buffer DebugBuffer {
    vec4 debugFlags[];
};

uniform float deltaTime;
uniform float seaLevel;
uniform vec3 cloudPosition;
uniform float cloudRadius;
uniform float minSpeed;
uniform float maxSpeed;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec4 generateRainDropPosition(vec3 cloudPosition, float cloudRadius) {
    float r = cloudRadius * rand(vec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y + 1));
    float theta = rand(vec2(gl_GlobalInvocationID.x + 2, gl_GlobalInvocationID.y + 2)) * 2.0 * 3.1415926f;
    float x = cloudPosition.x + r * cos(theta);
    float z = cloudPosition.z + r * sin(theta);
    return vec4(x, cloudPosition.y, z, 0.0f);
}

vec4 generateRainDropVelocity(float minSpeed, float maxSpeed) {
    float speed = minSpeed + rand(vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)) * (maxSpeed - minSpeed);
    return vec4(0.0f, -speed, 0.0f, 0.0f);
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    positions[index] += velocities[index] * deltaTime;
    debugFlags[index].x = positions[index].y;
    debugFlags[index].y = positions[index].y;
    debugFlags[index].z = 0;
    debugFlags[index].w = float(index);

    if (positions[index].y <= seaLevel) {
        positions[index] = generateRainDropPosition(cloudPosition, cloudRadius);
        velocities[index] = generateRainDropVelocity(minSpeed, maxSpeed);
        debugFlags[index].y = positions[index].y;
        debugFlags[index].z = 666;
    }
}
